# 功能流程与架构开发文档

> 本文面向本项目的功能开发与维护人员，按“功能点 → 流程 → 关键代码/组件 → 风险与建议”的结构梳理系统实现与架构取舍，便于快速理解与排障。

## 项目概览

- 技术栈
  - Spring Boot, Spring MVC, Spring AOP (@Transactional, AOP 代理)
  - MyBatis-Plus（ServiceImpl, BaseMapper）
  - Redis（String/Hash/GEO/Stream, Lua 脚本）
  - Redisson（分布式锁 RLock）
  - Hutool 工具集
  - Nginx（本地静态页面与反向代理）
- 关键模块
  - service/impl
    - ShopServiceImpl：店铺查询与缓存、GEO 附近查询
    - ShopTypeServiceImpl：店铺类型列表缓存
    - VoucherOrderServiceImpl：优惠券秒杀与下单
  - utils
    - CacheClient/CacheClient2：缓存模板方法（穿透/击穿/逻辑过期）
    - RedisData：携带逻辑过期时间的数据模型
    - RedisIdWorker/RedisIdWorker2：全局唯一 ID 生成
    - SimpleRedisLock2：基于 Redis 的分布式锁
  - resources
    - seckill2.lua：秒杀资格校验 + 预扣库存 + 投递消息的脚本

---

## 1）店铺详情查询与缓存（防穿透/防击穿/逻辑过期）

- 入口/调用链
  - Controller → `ShopServiceImpl.queryById(Long id)` → `CacheClient/CacheClient2` 模板
- 核心流程（缓存旁路 + 增强）
  1. 先查 Redis：命中直接返回。
  2. 未命中：
     - 穿透保护：DB 返回空对象则写入短 TTL 的空值并返回。
     - 击穿保护：互斥锁回源，单线程重建缓存；或使用逻辑过期（stale-while-revalidate）。
  3. 回写缓存：JSON + TTL，或 `RedisData{data, expireTime}`。
- 更新一致性
  - “先改库，后删缓存”：`ShopServiceImpl.update(..)` 成功后 `DEL` 缓存 key。
- 关键常量
  - Key：`CACHE_SHOP_KEY + id`；TTL：`CACHE_SHOP_TTL`（建议加抖动）。
- 风险与建议
  - 空值缓存 TTL 控制在数分钟；重建失败要有日志/重试；热点加逻辑过期更稳。

---

## 2）店铺类型列表缓存

- 入口/调用链
  - Controller → `ShopTypeServiceImpl.queryTypeList()`
- 核心流程
  1. 查 Redis List/JSON。
  2. 未命中回源 DB，写 Redis 并设 TTL。
- 建议
  - 加空值缓存与逻辑过期，避免穿透和击穿。

---

## 3）附近店铺搜索（GEO）

- 入口/调用链
  - Controller → `ShopServiceImpl.queryShopByType(typeId, current, x, y)`
- 核心流程
  1. Redis GEO（GEOSEARCH）按经纬度+距离取店铺 ID 与距离。
  2. 按顺序回表批量查 DB 并组装结果（保持顺序）。

---

## 4）登录鉴权与用户上下文

- 关键组件
  - `RefreshTokenInterceptor`：token 续期与用户上下文写入。
  - `LoginInterceptor`：登录校验。
  - `UserHolder`：ThreadLocal 保存/清理用户。
- 注意
  - 拦截器顺序保证“刷新在前、鉴权在后”；请求结束清理 ThreadLocal。

---

## 5）全局唯一 ID（RedisIdWorker/RedisIdWorker2）

- 算法
  - 高位：相对纪元时间戳；低位：Redis INCR 的序列号；组合位移生成全局唯一且趋势有序 ID。
- 用途
  - 订单号、主键、追踪 ID。
- 风险
  - 时钟回拨、Redis 故障要有降级与告警。

---

## 6）优惠券秒杀与下单

提供多套演进方案，推荐“Lua + Redis Stream + 异步消费者 + DB 乐观扣减 + 分布式锁/幂等”。

### 6.1 方案对比

- A：JVM synchronized（仅演示，本地单机）
- B：MySQL 乐观锁扣减库存
- C：Redis/Redisson 分布式锁 + 同步下单
- D（推荐）：Lua 资格校验 + 预扣库存 + XADD 到 Stream，消费者异步落库

### 6.2 Lua 脚本 seckill2.lua（资格 + 预扣 + 投递）

- 入参：`voucherId, userId, orderId`
- 步骤：
  1. 校验库存>0；2) 校验用户未下单；3) 扣减库存并记录用户；4) `XADD stream.orders` 投递消息。
- Java 侧先用 `RedisIdWorker` 生成 `orderId`，保证消息与 DB 订单号一致。

### 6.3 下单入口（同步返回、异步落库）

- `VoucherOrderServiceImpl.seckillVoucher(..)` / `seckillVoucherWithRedissonOptimization(..)`：
  1. 生成 orderId
  2. 执行 Lua，返回 0 表示获得资格，否则库存不足/重复下单
  3. 直接将 orderId 返回给前端

### 6.4 异步消费者（Redis Stream）

- 组件：`VoucherOrderServiceImpl.VoucherOrderHandler`
- 流程：
  - XREADGROUP g1 c1，反序列化为 `VoucherOrder` → `createVoucherOrder(voucherOrder)` → XACK
  - 异常：扫描 pending-list（起点 0）补偿处理
- 可靠性
  - 需预创建消费组 g1；对 pending-list 定期监控与告警。

### 6.5 事务与一人一单、库存扣减

- 落库：`createVoucherOrder(VoucherOrder)`（@Transactional）
  - Redisson 锁：`lock:order:{userId}`，避免同一用户并发多单
  - 一人一单：`count(*) where user_id=? and voucher_id=?` >0 拒绝
  - 扣减：`UPDATE .. SET stock = stock - 1 WHERE voucher_id=? AND stock > 0`

### 6.6 AOP 代理与自调用事务

- 同类内部调用事务方法需“通过代理”调用：
  - `IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();`
  - `return proxy.createVoucherOrder(voucherId);`
- 原因：Spring AOP 基于代理，自调用不会进入切面，事务不生效。
- 配置：`@EnableAspectJAutoProxy(exposeProxy = true)`

### 6.7 分布式锁

- SimpleRedisLock2：SETNX + EXPIRE（Lua 解锁，带标识）
- Redisson RLock：重入/续期/watch-dog，生产推荐
- 锁粒度：按 userId，范围小并发高。

### 6.8 建议

- DB 唯一索引：`UNIQUE(user_id, voucher_id)` 兜底一人一单
- 监控：Stream lag、pending 数、Lua 错误率、下单成功率

---

## 7）AOP 与事务规范

- 事务方法应为 public，位于接口实现上
- 自调用使用代理（AopContext 或注入自身接口再调）
- 控制事务边界，避免长事务

---

## 8）分布式锁规范

- Redisson：优先；注意 tryLock 超时时间与 finally 解锁
- 自研锁：设置过期、标识、Lua 原子解锁、必要时续期

---

## 9）配置与环境

- application.yaml：Redis、DB 连接，序列化，缓存 TTL 常量
- Redis Stream：初始化消费组（示例：`XGROUP CREATE stream.orders g1 $ MKSTREAM`）
- Nginx：`nginx-1.18.0/html/hmdp` 静态页联调

---

## 10）接口梳理（节选）

- 店铺
  - GET `/shop/{id}`：店铺详情（含缓存）
  - PUT `/shop`：更新（先改库后删缓存）
  - GET `/shop/of/type?typeId=&current=&x=&y=`：附近店铺（GEO）
- 店铺类型
  - GET `/shop-type/list`：类型列表（缓存）
- 秒杀
  - POST `/voucher-order/seckill/{id}`：执行 Lua 返回订单号（异步落库）
  - 其他演进接口：`seckillVoucherWithRedis/withRedisson/ByUser/...`

---

## 11）常见问题与排障

- 事务不生效：是否通过代理调用；方法是否 public；AOP 是否启用
- 重复下单：锁是否获取成功；DB 唯一索引是否生效
- Stream 堆积：消费者是否存活；pending-list 是否清理；ACK 是否成功
- 缓存频繁失效：逻辑过期重建是否失败；锁竞争是否异常

---

## 12）后续优化

- 注解化缓存（AOP）统一缓存策略
- 接口限流与风控（令牌桶/滑动窗口）
- 可观测性：QPS、RT、错误、命中率、Stream lag 指标与告警
- 容灾：ID 生成降级、Redis 主从/哨兵/集群与延迟可视化

> 文档随代码演进更新，若有偏差以代码为准，欢迎提交改进建议。
